/*******************************************************************************
 * Copyright 2015, The IKANOW Open Source Project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package com.ikanow.aleph2.data_model.utils;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;


/** Simple pattern matching utility for Java
 * @author acp
 */
public class Patterns {

	// CONSTRUCTORS
	
	/** Sets up a (simple) pattern matching chain - can either return a value or perform an action
	 * @param g - the value to act on
	 * @return an intermediate matcher, should call *either* .andAct() *or* .<R>andReturn() 
	 */
	public static <G> IntermediateMatcher<G> match(final G g) {
		return new IntermediateMatcher<G>(g);
	}
	/** Sets up a (simple) pattern matching chain - can either return a value or perform an action (this version enables you to just do () -> return for the predicates and results, eg just using closures from the local/global scope)
	 * @return an intermediate matcher, should call *either* .andAct() *or* .<R>andReturn() 
	 */
	public static IntermediateMatcher<Object> match() {
		return new IntermediateMatcher<Object>(null);
	}

	/** Intermediate step in the pattern matching chain - always resolved via .andAct() or .<R>andReturn()
	 * @author acp
	 *
	 * @param <G> the input type
	 */
	public static class IntermediateMatcher<G> {
		protected final G _g;
		protected IntermediateMatcher(final G g) { _g = g; }
		
		/** Sets up a return value - should be used in the following way
		 * Patterns.match(o).<RETURN_TYPE)andReturn().when(...)
		 * @return the return matcher
		 */
		public <R> Matcher<R, G> andReturn() {
			return new Matcher<R, G>(_g);
		}
		/** Sets up a match-then-act clause
		 * @return the action matcher
		 */
		public ActionMatcher<G> andAct() {
			return new ActionMatcher<G>(_g);
		}
	}
	
	/** Helper class for "pseudo-" pattern matching
	 * @author acp
	 *
	 * @param <R> the class of the return type
	 * @param <G> the class of the matching type
	 */
	public static class Matcher<R, G> {
		protected R _r;
		protected boolean _r_set = false;
		protected final G _g;
		protected Matcher(G g) {
			_g = g;
		}
		
		// PATTERN MATCHING
		
		/** Return value generated by expression if matching variable is of the specified class
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> Matcher<R, G> when(final Class<P> clazz, final Function<P, R> expression) {
			if (!_r_set && (null != _g) && clazz.isAssignableFrom(_g.getClass())) {
				_r = expression.apply(clazz.cast(_g));
				_r_set = true;
			}
			return this;
		}
		/** Return value generated by expression if matching variable is of the specified class
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> Matcher<R, G> when(final Class<P> clazz, final Supplier<R> expression) {
			if (!_r_set && (null != _g) && clazz.isAssignableFrom(_g.getClass())) {
				_r = expression.get();
				_r_set = true;
			}
			return this;
		}
		
		/** Return value generated by expression if matching variable is of the specified class *and* the predicate resolves to true
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> Matcher<R, G> when(final Class<P> clazz, final Predicate<P> predicate, final Function<P, R> expression) {
			if (!_r_set && (null != _g) && clazz.isAssignableFrom(_g.getClass())) {
				P p = clazz.cast(_g);
				if (predicate.test(p)) {
					_r = expression.apply(p);
					_r_set = true;
				}
			}
			return this;
		}
		/** Return value generated by expression if matching variable is of the specified class *and* the predicate resolves to true
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> Matcher<R, G> when(final Class<P> clazz, final Supplier<Boolean> predicate, final Supplier<R> expression) {
			if (!_r_set && (null != _g) && clazz.isAssignableFrom(_g.getClass())) {
				if (predicate.get()) {
					_r = expression.get();
					_r_set = true;
				}
			}
			return this;
		}
		/** Return value generated by expression if the predicate resolves to true
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public Matcher<R, G> when(final Predicate<G> predicate, final Function<G, R> expression) {
			if (!_r_set && predicate.test(_g)) {
				_r = expression.apply(_g);
				_r_set = true;
			}
			return this;
		}
		/** Return value generated by expression if the predicate resolves to true
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public Matcher<R, G> when(final Supplier<Boolean> predicate, final Supplier<R> expression) {
			if (!_r_set && predicate.get()) {
				_r = expression.get();
				_r_set = true;
			}
			return this;
		}
		
		// DEFAULT OPERATIONS
		
		/** If none of the when clauses applies, then returns the value specified by the expresson
		 * @param expression evaluates to the return value, taking the matching variable as the input
		 * @return the return value from the matching clause or this otherwise
		 */
		public R otherwise(final Function<G, R> expression) {
			if (_r_set) {
				return _r;
			}
			else {
				return expression.apply(_g);
			}
		}
		/** If none of the when clauses applies, then returns the value specified by the expresson
		 * @param expression evaluates to the return value, taking the matching variable as the input
		 * @return the return value from the matching clause or this otherwise
		 */
		public R otherwise(final Supplier<R> expression) {
			if (_r_set) {
				return _r;
			}
			else {
				return expression.get();
			}
		}
		
		/** For typical cases where the list of whens is (by construction) exhaustive, this method can be used to avoid
		 *  having a spurious otherwise(--do something but it doesn't matter what because this will never get executed--) statement
		 * @param assertion
		 * @return the value (throws if it isn't met)
		 */
		public R otherwiseAssert(final Optional<String> assertion) {
			return otherwise(() -> { throw new RuntimeException("Matcher.otherwiseAssert: " + assertion.orElse("")); });
		}
		/** For typical cases where the list of whens is (by construction) exhaustive, this method can be used to avoid
		 *  having a spurious otherwise(--do something but it doesn't matter what because this will never get executed--) statement
		 * @return the value (throws if it isn't met)
		 */
		public R otherwiseAssert() {
			return otherwiseAssert(Optional.empty());
		}
	}

	public static class ActionMatcher<G> {
		protected boolean _r_set = false;
		protected G _g;
		boolean _allow_multiple = false;
		protected ActionMatcher(G g) {
			_g = g;
		}

		// OPTIONS
		
		/** Allows multiple actions to be performed it multiple when clauses match, otherwise only the first (matches in order)
		 * @return The matching utility
		 */
		public ActionMatcher<G> allowMultiple() {
			_allow_multiple = true;
			return this;
		}
		
		// PATTERN MATCHING
		
		/** Performs action specified by expression if matching variable is of the specified class
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param expression performs some action, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> ActionMatcher<G> when(final Class<P> clazz, final Consumer<P> expression) {
			if ((!_r_set || _allow_multiple) && ((null != _g) && clazz.isAssignableFrom(_g.getClass()))) {
				expression.accept(clazz.cast(_g));
				_r_set = true;
			}
			return this;
		}		
		/** Performs action specified by expression if matching variable is of the specified class
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param expression performs some action, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> ActionMatcher<G> when(final Class<P> clazz, final Runnable expression) {
			if ((!_r_set || _allow_multiple) && ((null != _g) && clazz.isAssignableFrom(_g.getClass()))) {
				expression.run();
				_r_set = true;
			}
			return this;
		}		
		/** Performs action specified by expression if matching variable is of the specified class *and* the specified predicate is true
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression performs some action, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> ActionMatcher<G> when(final Class<P> clazz, final Predicate<P> predicate, final Consumer<P> expression) {
			if ((!_r_set || _allow_multiple) && ((null != _g) && clazz.isAssignableFrom(_g.getClass()))) {
				P p = clazz.cast(_g);
				if (predicate.test(p)) {
					expression.accept(p);
					_r_set = true;
				}
			}
			return this;
		}
		/** Performs action specified by expression if matching variable is of the specified class *and* the specified predicate is true
		 * @param clazz class to match against. NOTE: to handle inner generics, use the construct (Class<O<I1, I2, ..>>)(Class<?>)O.class - this will only check the outer class, but will infer the type of the inner classes in the lambda.
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression performs some action, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> ActionMatcher<G> when(final Class<P> clazz, final Supplier<Boolean> predicate, final Runnable expression) {
			if ((!_r_set || _allow_multiple) && ((null != _g) && clazz.isAssignableFrom(_g.getClass()))) {
				if (predicate.get()) {
					expression.run();
					_r_set = true;
				}
			}
			return this;
		}
		/** Performs action specified by expression if the predicate resolves to true
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public ActionMatcher<G> when(final Predicate<G> predicate, final Consumer<G> expression) {
			if (!_r_set && predicate.test(_g)) {
				expression.accept(_g);
				_r_set = true;
			}
			return this;
		}
		/** Performs action specified by expression if the predicate resolves to true
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public ActionMatcher<G> when(final Supplier<Boolean> predicate, final Runnable expression) {
			if (!_r_set && predicate.get()) {
				expression.run();
				_r_set = true;
			}
			return this;
		}
		
		// DEFAULT OPERATIONS
		
		/** If none of the when clauses applies, then throws the specified exception  
		 * @param t the exception to throw
		 */
		public void otherwise(final Throwable t) throws Throwable {
			if (!_r_set) {
				throw t;
			}
		}
		/** If none of the when clauses applies, then performs the specified action  
		 * @param expression the lambda to perform, taking the matching variable as the input
		 */
		public void otherwise(final Consumer<G> expression) {
			if (!_r_set) {
				expression.accept(_g);
			}
		}		
		/** If none of the when clauses applies, then performs the specified action  
		 * @param expression the lambda to perform, taking the matching variable as the input
		 */
		public void otherwise(Runnable expression) {
			if (!_r_set) {
				expression.run();
			}
		}		
		/** For typical cases where the list of whens is (by construction) exhaustive, this method can be used to avoid
		 *  having a spurious otherwise(--do something but it doesn't matter what because this will never get executed--) statement
		 * @param assertion
		 * @return the value (throws if it isn't met)
		 */
		public void otherwiseAssert(final Optional<String> assertion) {
			otherwise(() -> { throw new RuntimeException("ActionMatcher.otherwiseAssert: " + assertion.orElse("")); });
		}
		/** For typical cases where the list of whens is (by construction) exhaustive, this method can be used to avoid
		 *  having a spurious otherwise(--do something but it doesn't matter what because this will never get executed--) statement
		 * @return the value (throws if it isn't met)
		 */
		public void otherwiseAssert() {
			otherwiseAssert(Optional.empty());
		}
	}	
}