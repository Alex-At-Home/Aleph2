/*******************************************************************************
 * Copyright 2015, The IKANOW Open Source Project.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.ikanow.aleph2.data_model.utils;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

public class Patterns {

	// CONSTRUCTORS
	
	/** Matching on an object, returns the result
	 * @param g the variable on which to match
	 * @return the matcher helper class
	 */
	public static <G> Matcher<Object, G> matchAndReturn(G g) {
		return new Matcher<Object, G>(g);
	}
	/** Matching on an object, returns the result (specify the class of the result up front)
	 * @param g the variable on which to match
	 * @param clazz the class of the return value
	 * @return the matcher helper class
	 */
	public static <G, R> Matcher<R, G> matchAndReturn(G g, Class<R> clazz) {
		return new Matcher<R, G>(g);
	}
	/** Matching on an object, act on the result (no return value)
	 * @param g the variable on which to match
	 * @return the matcher helper class
	 */
	public static <G> ActionMatcher<G> matchAndAct(G g) {
		return new ActionMatcher<G>(g);
	}
	
	/** Helper class for "pseudo-" pattern matching
	 * @author acp
	 *
	 * @param <R> the class of the return type
	 * @param <G> the class of the matching type
	 */
	public static class Matcher<R, G> {
		protected R _r;
		protected boolean _r_set = false;
		protected G _g;
		protected Matcher(G g) {
			_g = g;
		}
		
		// PATTERN MATCHING
		
		/** Return value generated by expression if matching variable is of the specified class
		 * @param clazz class to match against
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> Matcher<R, G> when(Class<P> clazz, Function<P, R> expression) {
			if (!_r_set && clazz.isAssignableFrom(_g.getClass())) {
				_r = expression.apply(clazz.cast(_g));
				_r_set = true;
			}
			return this;
		}
		/** Return value generated by expression if matching variable is of the specified class *and* the predicate resolves to true
		 * @param clazz class to match against
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> Matcher<R, G> when(Class<P> clazz, Predicate<P> predicate, Function<P, R> expression) {
			if (!_r_set && clazz.isAssignableFrom(_g.getClass())) {
				P p = clazz.cast(_g);
				if (predicate.test(p)) {
					_r = expression.apply(p);
					_r_set = true;
				}
			}
			return this;
		}
		/** Return value generated by expression if the predicate resolves to true
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public Matcher<R, G> when(Predicate<G> predicate, Function<G, R> expression) {
			if (!_r_set && predicate.test(_g)) {
				_r = expression.apply(_g);
				_r_set = true;
			}
			return this;
		}
		
		// DEFAULT OPERATIONS
		
		/** If none of the when clauses applies, then returns the value specified by the expresssion 
		 * @param expression evaluates to the return value, taking the matching variable as the input
		 * @return the return value from the matching clause or this otherwise
		 */
		@SuppressWarnings("unchecked")
		public <RR> RR otherwise(Function<G, RR> expression) {
			if (_r_set) {
				return (RR) _r;
			}
			else {
				return expression.apply(_g);
			}
		}
		/** If none of the when clauses applies, then throws the specified exception  
		 * @param t the exception to throw
		 * @return the return value from the matching clause
		 */
		@SuppressWarnings("unchecked")
		public <RR> RR otherwise(Throwable t) throws Throwable {
			if (_r_set) {
				return (RR) _r;
			}
			else {
				throw t;
			}
		}
		/** If none of the when clauses applies, then performs the specified action (no return)
		 * @param expression the action to perform, taking the matching variable as the input
		 */
		public void otherwiseDo(Consumer<G> expression) {
			if (!_r_set) {
				expression.accept(_g);
			}
		}
	}

	public static class ActionMatcher<G> {
		protected boolean _r_set = false;
		protected G _g;
		boolean _allow_multiple = false;
		protected ActionMatcher(G g) {
			_g = g;
		}

		// OPTIONS
		
		/** Allows multiple actions to be performed it multiple when clauses match, otherwise only the first (matches in order)
		 * @return The matching utility
		 */
		public ActionMatcher<G> allowMultiple() {
			_allow_multiple = true;
			return this;
		}
		
		// PATTERN MATCHING
		
		/** Performs action specified by expression if matching variable is of the specified class
		 * @param clazz class to match against
		 * @param expression performs some action, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> ActionMatcher<G> when(Class<P> clazz, Consumer<P> expression) {
			if ((!_r_set || _allow_multiple) && (clazz.isAssignableFrom(_g.getClass()))) {
				expression.accept(clazz.cast(_g));
				_r_set = true;
			}
			return this;
		}		
		/** Performs action specified by expression if matching variable is of the specified class *and* the specified predicate is true
		 * @param clazz class to match against
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression performs some action, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public <P> ActionMatcher<G> when(Class<P> clazz, Predicate<P> predicate, Consumer<P> expression) {
			if ((!_r_set || _allow_multiple) && (clazz.isAssignableFrom(_g.getClass()))) {
				P p = clazz.cast(_g);
				if (predicate.test(p)) {
					expression.accept(p);
					_r_set = true;
				}
			}
			return this;
		}
		/** Performs action specified by expression if the predicate resolves to true
		 * @param predicate lambda returning true/false, taking the matching variable as the input
		 * @param expression evaluates to the return value, taking the matching variable as the input 
		 * @return Matching utility
		 */
		public ActionMatcher<G> when(Predicate<G> predicate, Consumer<G> expression) {
			if (!_r_set && predicate.test(_g)) {
				expression.accept(_g);
				_r_set = true;
			}
			return this;
		}
		
		// DEFAULT OPERATIONS
		
		/** If none of the when clauses applies, then throws the specified exception  
		 * @param t the exception to throw
		 */
		public void otherwise(Throwable t) throws Throwable {
			if (!_r_set) {
				throw t;
			}
		}
		/** If none of the when clauses applies, then performs the specified action  
		 * @param expression the lambda to perform, taking the matching variable as the input
		 */
		public void otherwise(Consumer<G> expression) {
			if (!_r_set) {
				expression.accept(_g);
			}
		}		
	}	
}