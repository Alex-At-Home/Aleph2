/*******************************************************************************
 * Copyright 2015, The IKANOW Open Source Project.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.ikanow.aleph2.data_model.interfaces.data_analytics;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.stream.Stream;

import com.fasterxml.jackson.databind.JsonNode;
import com.ikanow.aleph2.data_model.interfaces.shared_services.ICrudService;
import com.ikanow.aleph2.data_model.interfaces.shared_services.IServiceContext;
import com.ikanow.aleph2.data_model.objects.data_analytics.AnalyticThreadBean;
import com.ikanow.aleph2.data_model.objects.data_import.DataBucketBean;
import com.ikanow.aleph2.data_model.objects.shared.BasicMessageBean;

//TODO (ALEPH-12): this needs a pretty hefty rework

/** A context library that is always passed to the IAnalyticsTechnology module and can also be 
 *  passed to the analytics library processing (TODO (ALEPH-12): need to document how, ie copy JARs into external classpath and call ContextUtils.getAnalyticsContext)
 * @author acp
 */
public interface IAnalyticsContext {

	//////////////////////////////////////////////////////
	
	// ANALYTICS MODULE ONLY
	
	/** (HarvesterModule only) Returns context to return a service - for external clients, the corresponding library JAR must have been copied into the class file (path given by getAnalyticsContextLibraries)
	 * (NOTE: analytic technology modules do not need this, they can access the service context directly via the @Inject annotation)    
	 * @return the service context
	 */
	IServiceContext getServiceContext();	
	
	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param bucket - the bucket to monitor
	 * @param stage - if set to Optionals.empty() then occurs post enrichment. If set to "" then occurs pre-enrichment. Otherwise should be the name of a module - will listen immediately after that. 
	 * @param on_new_object_callback - a void function taking a JsonNode (the object) 
	 * @return a future that completes when the subscription has occurred, describing its success or failure
	 */
	CompletableFuture<BasicMessageBean> subscribeToBucket(final DataBucketBean bucket, final Optional<String> stage, final Consumer<JsonNode> on_new_object_callback);
	
	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param analytic_thread - the thread to monitor
	 * @param stage - if set to Optionals.empty() then occurs post processing. If set to "" then occurs pre-processing. Otherwise should be the name of a module - will listen immediately after that. 
	 * @param on_new_object_callback - a void function taking a JsonNode (the object) 
	 * @return a future that completes when the subscription has occurred, describing its success or failure
	 */
	CompletableFuture<BasicMessageBean> subscribeToAnalyticThread(final AnalyticThreadBean analytic_thread, final Optional<String> stage, final Consumer<JsonNode> on_new_object_callback);
	
	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param bucket - the bucket to monitor
	 * @param stage - if set to Optionals.empty() then occurs post enrichment. If set to "" then occurs pre-enrichment. Otherwise should be the name of a module - will listen immediately after that. 
	 * @return a future returning stream of Json nodes as soon as the connection is established
	 */
	CompletableFuture<Stream<JsonNode>> getObjectStreamFromBucket(final DataBucketBean bucket, final Optional<String> stage);
	
	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param analytic_thread - the analytic thread to monitor
	 * @param stage - if set to Optionals.empty() then occurs post processing. If set to "" then occurs pre-processing. Otherwise should be the name of a module - will listen immediately after that. 
	 * @return a future returning stream of Json nodes as soon as the connection is established
	 */
	Stream<JsonNode> getObjectStreamFromAnalyticThread(final AnalyticThreadBean analytic_thread, final Optional<String> stage);
	
	//////////////////////////////////////////////////////
	
	// ANALYTICS TECHNOLOGY ONLY 
	
	/** (AnalyticsTechnology only) A list of JARs that can be copied to an external process (eg Hadoop job) to provide the result client access to this context (and other services)
	 * @services an optional set of service classes that are needed (only the libraries needed for the context is provided otherwise)
	 * @return the path (in a format that makes sense to IStorageService)
	 */
	List<String> getAnalyticsContextLibraries(final Optional<Set<Class<?>>> services);
	
	/** (AnalyticsTechnology only) This string should be passed into ContextUtils.getAnalyticsContext to retrieve this class from within external clients
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the thread then Optional.empty() can be passed (Note that the behavior of the context if called on another thread than the one currently being processed is undefined) 
	 * @return an opaque string that can be passed into ContextUtils.getAnalyticsContext
	 */
	String getAnalyticsContextSignature(final Optional<AnalyticThreadBean> analytic_thread);

	/** (AnalyticsTechnology only) Get the global (ie analytics technology-specific _not_ thread-specific) configuration
	 * @return A Future containing a JsonNode representing the "analytics technology specific configuration"
	 */
	CompletableFuture<JsonNode> getGlobalAnalyticsTechnologyConfiguration();
	
	/** (AnalyticsTechnology only) For each library defined by the analytic_thread.xxx (TODO: ALEPH-12), returns a FileSystem path 
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the thread then Optional.empty() can be passed (Note that the behavior of the context if called on another thread than the one currently being processed is undefined) 
	 * @return A Future containing a map of filesystem paths with key both the name and id of the library 
	 */
	CompletableFuture<Map<String, String>> getAnalyticsLibraries(final Optional<AnalyticThreadBean> analytic_thread);
	
	//////////////////////////////////////////////////////
	
	// BOTH ANALYTICS TECHNOLOGY AND ANALYTICS MODULE 
	
	/** (AnalyticsTechnology/Analytics Module) Returns an object repository that the technology/module can use to store arbitrary internal state
	 * @param clazz The class of the bean or object type desired (needed so the repo can reason about the type when deciding on optimizations etc)
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 * @param sub_collection - arbitrary string, enables the user to split the per analytic thread state into multiple independent collections. If left empty then defaults to "analytics". It is recommended to prefix with "analytics_" (or leave auto_apply_prefix true) to avoid collisions with enrichment/harvest modules.
	 * @param auto_apply_prefix - if true then auto applies the prefix "analytics_" to the supplied sub-collection 
	 * @return a generic object repository
	 */
	<S> ICrudService<S> getThreadObjectStore(final Class<S> clazz, final Optional<AnalyticThreadBean> analytic_thread, final Optional<String> sub_collection, final boolean auto_apply_prefix);
		
	/** (AnalyticsTechnology/Analytics Module) Calling this function logs a status message into he AnalyticThreadStatusBean that is visible to the user
	 * Note that the behavior of the context if called on another analytic thread than the one
	 * currently being processed is undefined
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 * @param message The message to log
	 * @param roll_up_duplicates if set (default: true) then identical messages are not logged separately 
	 */
	void logStatusForThreadOwner(final Optional<AnalyticThreadBean> analytic_thread, final BasicMessageBean message, final boolean roll_up_duplicates);
	
	/** (AnalyticsTechnology/Analytics Module) Calling this function logs a status message into he AnalyticThreadStatusBean that is visible to the user
	 * @param analytic thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 * @param The message to log (duplicates are "rolled up")
	 */
	void logStatusForThreadOwner(final Optional<AnalyticThreadBean> analytic_thread, final BasicMessageBean message);
	
	/** (AnalyticsTechnology/Analytics Module) Requests that the analytic thread be suspended - in addition to changing the analytic thread state, this will result in a call to IAnalyticsTechnologyModule.onSuspend
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 */
	void emergencyDisableThread(final Optional<AnalyticThreadBean> analytic_thread);
	
	/** (AnalyticsTechnology/Analytics Module) Requests that the analytic thread be suspended for the specified duration - in addition to changing the analytic thread state, this will result in a call to IAnalyticsTechnologyModule.onSuspend
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined)
	 * @param  quarantineDuration A string representing the duration for which to quarantine the data (eg "1 hour", "2 days", "3600")
	 */
	void emergencyQuarantineThread(final Optional<AnalyticThreadBean> analytic_thread, final String quarantine_duration);

	//////////////////////////////////////////////////////
	
	// NEITHER 
	
	/** (Should never be called by clients) this is used by the infrastructure to set up external contexts
	 * @param signature the string returned from getAnalyticsContextSignature
	 */
	void initializeNewContext(final String signature);	
}
