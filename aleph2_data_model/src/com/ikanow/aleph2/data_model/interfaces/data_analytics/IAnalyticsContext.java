/*******************************************************************************
 * Copyright 2015, The IKANOW Open Source Project.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.ikanow.aleph2.data_model.interfaces.data_analytics;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.function.Consumer;
import java.util.stream.Stream;

import org.checkerframework.checker.nullness.qual.NonNull;

import com.fasterxml.jackson.databind.JsonNode;
import com.ikanow.aleph2.data_model.interfaces.shared_services.ICrudService;
import com.ikanow.aleph2.data_model.objects.data_analytics.AnalyticThreadBean;
import com.ikanow.aleph2.data_model.objects.data_analytics.AnalyticThreadStatusBean;
import com.ikanow.aleph2.data_model.objects.data_import.DataBucketBean;
import com.ikanow.aleph2.data_model.objects.shared.BasicMessageBean;

/** A context library that is always passed to the IAnalyticsTechnology module and can also be 
 *  passed to the analytics library processing (TODO: need to document how, ie copy JARs into external classpath and call ContextUtils.getAnalyticsContext)
 * @author acp
 */
public interface IAnalyticsContext {

	//////////////////////////////////////////////////////
	
	// ANALYTICS MODULE ONLY
	
	/** (Analytics Module only) Returns a service - for external clients, the corresponding library JAR must have been copied into the class file (path given by getAnalyticContextLibraries)
	 * (NOTE: analytic technology modules do not need this, they can access the required service directly via the @Inject annotation)    
	 * @param service_clazz - the class of the object desired; if specified, this overrides to a secondary service
	 * @param service_name - optional - if ommitted, this is the default service of this type
	 * @return the requested service
	 */
	<I> I getService(@NonNull Class<I> service_clazz, @NonNull Optional<String> service_name);

	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param bucket - the bucket to monitor
	 * @param stage - if set to Optionals.empty() then occurs post enrichment. If set to "" then occurs pre-enrichment. Otherwise should be the name of a module - will listen immediately after that. 
	 * @param on_new_object_callback - a void function taking a JsonNode (the object) 
	 * @return a future that completes when the subscription has occurred, describing its success or failure
	 */
	Future<BasicMessageBean> subscribeToBucket(@NonNull DataBucketBean bucket, @NonNull Optional<String> stage, Consumer<JsonNode> on_new_object_callback);
	
	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param analytic_thread - the thread to monitor
	 * @param stage - if set to Optionals.empty() then occurs post processing. If set to "" then occurs pre-processing. Otherwise should be the name of a module - will listen immediately after that. 
	 * @param on_new_object_callback - a void function taking a JsonNode (the object) 
	 * @return a future that completes when the subscription has occurred, describing its success or failure
	 */
	Future<BasicMessageBean> subscribeToAnalyticThread(@NonNull AnalyticThreadBean analytic_thread, @NonNull Optional<String> stage, Consumer<JsonNode> on_new_object_callback);
	
	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param bucket - the bucket to monitor
	 * @param stage - if set to Optionals.empty() then occurs post enrichment. If set to "" then occurs pre-enrichment. Otherwise should be the name of a module - will listen immediately after that. 
	 * @return a future returning stream of Json nodes as soon as the connection is established
	 */
	Future<Stream<JsonNode>> getObjectStreamFromBucket(@NonNull DataBucketBean bucket, @NonNull Optional<String> stage);
	
	/** Enables analytic modules to subscribe to objects being generated by other components in the system
	 *  This callback can be used eg to inject data into a Storm spout, or to generate data in standalone Java applications 
	 * @param analytic_thread - the analytic thread to monitor
	 * @param stage - if set to Optionals.empty() then occurs post processing. If set to "" then occurs pre-processing. Otherwise should be the name of a module - will listen immediately after that. 
	 * @return a future returning stream of Json nodes as soon as the connection is established
	 */
	Stream<JsonNode> getObjectStreamFromAnalyticThread(@NonNull AnalyticThreadBean analytic_thread, @NonNull Optional<String> stage);
	
	//////////////////////////////////////////////////////
	
	// ANALYTICS TECHNOLOGY ONLY 
	
	/** (AnalyticsTechnology only) A list of JARs that can be copied to an external process (eg Hadoop job) to provide the result client access to this context (and other services)
	 * @services an optional set of service classes that are needed (only the libraries needed for the context is provided otherwise)
	 * @return the path (in a format that makes sense to IStorageService)
	 */
	List<String> getAnalyticsContextLibraries(@NonNull Optional<Set<Class<?>>> services);
	
	/** (AnalyticsTechnology only) This string should be passed into ContextUtils.getAnalyticsContext to retrieve this class from within external clients
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the thread then Optional.empty() can be passed (Note that the behavior of the context if called on another thread than the one currently being processed is undefined) 
	 * @return an opaque string that can be passed into ContextUtils.getAnalyticsContext
	 */
	String getAnalyticsContextSignature(@NonNull Optional<AnalyticThreadBean> analytic_thread);

	/** (AnalyticsTechnology only) Get the global (ie analytics technology-specific _not_ thread-specific) configuration
	 * @return A Future containing a JsonNode representing the "analytics technology specific configuration"
	 */
	Future<JsonNode> getGlobalAnalyticsTechnologyConfiguration();
	
	/** (AnalyticsTechnology only) For each library defined by the analytic_thread.XXX, returns a FileSystem path 
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the thread then Optional.empty() can be passed (Note that the behavior of the context if called on another thread than the one currently being processed is undefined) 
	 * @return A Future containing a map of filesystem paths with key both the name and id of the library 
	 */
	Future<Map<String, String>> getAnalyticsLibraries(@NonNull Optional<AnalyticThreadBean> analytic_thread);
	
	//////////////////////////////////////////////////////
	
	// BOTH ANALYTICS TECHNOLOGY AND ANALYTICS MODULE 
	
	/** (AnalyticsTechnology/Analytics Module) Returns an object repository that the technology/module can use to store arbitrary internal state
	 * @param clazz The class of the bean or object type desired (needed so the repo can reason about the type when deciding on optimizations etc)
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 * @param sub_collection - arbitrary string, enables the user to split the per analytic thread state into multiple independent collections. If left empty then defaults to "analytics". It is recommended to prefix with "analytics_" (or leave auto_apply_prefix true) to avoid collisions with enrichment/harvest modules.
	 * @param auto_apply_prefix - if true then auto applies the prefix "analytics_" to the supplied sub-collection 
	 * @return a generic object repository
	 */
	<S> ICrudService<S> getThreadObjectStore(@NonNull Class<S> clazz, @NonNull Optional<AnalyticThreadBean> analytic_thread, @NonNull Optional<String> sub_collection, boolean auto_apply_prefix);
	
	/** (AnalyticsTechnology/Analytics Module) Returns the status bean for the specified analytic thread
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 * @return A Future containing a bean containing the analytics' state and status
	 */
	Future<AnalyticThreadStatusBean> getThreadStatus(@NonNull Optional<AnalyticThreadBean> analytic_thread);
	
	/** (AnalyticsTechnology/Analytics Module) Calling this function logs a status message into he AnalyticThreadStatusBean that is visible to the user
	 * Note that the behavior of the context if called on another analytic thread than the one
	 * currently being processed is undefined
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 * @param message The message to log
	 * @param roll_up_duplicates if set (default: true) then identical messages are not logged separately 
	 */
	void logStatusForThreadOwner(@NonNull Optional<AnalyticThreadBean> analytic_thread, @NonNull BasicMessageBean message, boolean roll_up_duplicates);
	
	/** (AnalyticsTechnology/Analytics Module) Calling this function logs a status message into he AnalyticThreadStatusBean that is visible to the user
	 * @param analytic thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 * @param The message to log (duplicates are "rolled up")
	 */
	void logStatusForThreadOwner(@NonNull Optional<AnalyticThreadBean> analytic_thread, @NonNull BasicMessageBean message);
	
	/** (AnalyticsTechnology/Analytics Module) Requests that the analytic thread be suspended - in addition to changing the analytic thread state, this will result in a call to IAnalyticsTechnologyModule.onSuspend
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined) 
	 */
	void emergencyDisableThread(@NonNull Optional<AnalyticThreadBean> analytic_thread);
	
	/** (AnalyticsTechnology/Analytics Module) Requests that the analytic thread be suspended for the specified duration - in addition to changing the analytic thread state, this will result in a call to IAnalyticsTechnologyModule.onSuspend
	 * @param analytic_thread An optional analytic thread - if there is no ambiguity in the analytic thread then Optional.empty() can be passed (Note that the behavior of the context if called on another analytic thread than the one currently being processed is undefined)
	 * @param  quarantineDuration A string representing the duration for which to quarantine the data (eg "1 hour", "2 days", "3600")
	 */
	void emergencyQuarantineThread(@NonNull Optional<AnalyticThreadBean> analytic_thread, @NonNull String quarantine_duration);

	//////////////////////////////////////////////////////
	
	// NEITHER 
	
	/** (Should never be called by clients) this is used by the infrastructure to set up external contexts
	 * @param signature the string returned from getAnalyticsContextSignature
	 */
	void initializeNewContext(@NonNull String signature);	
}
