/*******************************************************************************
 * Copyright 2015, The IKANOW Open Source Project.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.ikanow.aleph2.data_model.interfaces.shared_services;

import java.time.Duration;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

import scala.Tuple2;

import com.fasterxml.jackson.databind.JsonNode;

/** A write only object store - no concept of deduplication, querying, updates etc - then is extended by ICrudService to provide the full functionality
 * @author Alex
 *
 * @param <O>
 */
public interface IDataWriteService<O> {

	//////////////////////////////////////////////////////
	
	// *C*REATE
	
	/** Stores the specified object in the database, failing if it is already present
	 *  If the "_id" field of the object is not set then it is assigned
	 * @param new_object
	 * @return A future containing the _id (filled in if not present in the object) - accessing the future will also report on errors via ExecutionException 
	 */
	CompletableFuture<Supplier<Object>> storeObject(final O new_object);
	
	/**
	 * @param objects - a list of objects to insert, not handling duplicates
	 * @return A future containing the list of _ids (filled in if not present in the object), and the number of docs retrieved - accessing the future will also report on errors via ExecutionException 
	 */
	CompletableFuture<Tuple2<Supplier<List<Object>>, Supplier<Long>>> storeObjects(final List<O> new_objects);
	
	
	//////////////////////////////////////////////////////
	
	// *R*ETRIEVE
	
	/** Counts the number of objects in the data store
	 * @param spec A specification generated by CrudUtils.allOf(...) (all fields must be match) or CrudUtils.anyOf(...) (any fields must match) together with extra fields generated by .withAny(..), .withAll(..), present(...) or notPresent(...)   
	 * @return A future containing the number of matching objects - accessing the future will also report on errors via ExecutionException 
	 */
	CompletableFuture<Long> countObjects();
	
	//////////////////////////////////////////////////////
	
	// *D*ELETE
	
	/** Deletes the entire datastore and all documents, including mappings/indexes/metdata etc
	 * @return a future describing if the delete was successful - accessing the future will also report on errors via ExecutionException
	 */
	CompletableFuture<Boolean> deleteDatastore();
	
	//////////////////////////////////////////////////////
	
	// BATCH:

	/** Retrieves a batch write subservice if one exists
	 * @return the batch write subservice
	 */
	default Optional<IBatchSubservice<O>> getBatchWriteSubservice() {
		return Optional.empty();
	}
	
	/** A more efficient batch interface that may or may not be implemented
	 * @author Alex
	 */
	public static interface IBatchSubservice<O> {
		/** Sets the batching parameters
		 * @param max_objects - the max number of records before a batch is flushed
		 * @param size_kb - the max size before a batch is flushed
		 * @param flush_interval - the max time before a batch is flushed
		 * @param write_threads - the requested number of write threads (this is not guaranteed to be granted, but will be taken into account)
		 */
		void setBatchProperties(final Optional<Integer> max_objects, final Optional<Long> size_kb, final Optional<Duration> flush_interval, final Optional<Integer> write_threads);
		
		/** Efficiently store the list of objects with the subservice's batching parameters
		 * @param new_objects - the list of objects to store
		 * @param replace_if_present - if true, will overwrite existing elements; if false may error in which case the behavior of other objects is undefined (but this is safe to use if using UUIDs for _id or ommitting _id, which is equivalent)
		 */
		void storeObjects(final List<O> new_objects);
		
		/** Efficiently store the single object with the subservice's batching parameters
		 * @param new_object - the single object to store efficiently
		 * @param replace_if_present - if true, will overwrite existing elements; if false may error in which case the behavior of other objects is undefined (but this is safe to use if using UUIDs for _id or ommitting _id, which is equivalent)
		 */
		void storeObject(final O new_object);
	}
	
	//////////////////////////////////////////////////////
	
	// OTHER:

	/** If this is an underlying CRUD service (Eg a database not a file store), then the underlying technology can be retrieved from this method 
	 * @return the full CRUD service, if it exists
	 */
	Optional<ICrudService<O>> getCrudService();
	
	/** Returns an identical version of this CRUD service but using JsonNode instead of beans (which may save serialization)
	 * @return the JsonNode-genericized version of this same CRUD service
	 */
	IDataWriteService<JsonNode> getRawService();
	
	/** USE WITH CARE: this returns the driver to the underlying technology
	 *  shouldn't be used unless absolutely necessary!
	 * @param driver_class the class of the driver
	 * @param a string containing options in some technology-specific format
	 * @return a driver to the underlying technology. Will exception if you pick the wrong one!
	 */
	<T> Optional<T> getUnderlyingPlatformDriver(final Class<T> driver_class, final Optional<String> driver_options);
}
